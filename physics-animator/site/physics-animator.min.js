
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var PhysicsAnimator = (function () {
  'use strict';

  var dpEventEmitter = {exports: {}};

  (function (module) {
  	class DPEventEmitter {
  	  #events;

  	  constructor() {
  	    this.#events = new Map();
  	  }

  	  /**
  	   * Binds a listener to an event.
  	   * @param {string} event - The event to bind the listener to.
  	   * @param {Function} listener - The listener function to bind.
  	   * @returns {DPEventEmitter} The current instance for chaining.
  	   * @throws {TypeError} If the listener is not a function.
  	   */
  	  on(event, listener) {
  	    if (typeof listener !== 'function') {
  	      throw new TypeError('Listener must be a function');
  	    }

  	    const listeners = this.#events.get(event) || [];
  	    if (!listeners.includes(listener)) {
  	      listeners.push(listener);
  	    }
  	    this.#events.set(event, listeners);

  	    return this;
  	  }

  	  /**
  	   * Unbinds a listener from an event.
  	   * @param {string} event - The event to unbind the listener from.
  	   * @param {Function} listener - The listener function to unbind.
  	   * @returns {DPEventEmitter} The current instance for chaining.
  	   */
  	  off(event, listener) {
  	    const listeners = this.#events.get(event);
  	    if (!listeners) return this;

  	    const index = listeners.indexOf(listener);
  	    if (index !== -1) {
  	      listeners.splice(index, 1);
  	      if (listeners.length === 0) {
  	        this.#events.delete(event);
  	      } else {
  	        this.#events.set(event, listeners);
  	      }
  	    }

  	    return this;
  	  }

  	  /**
  	   * Triggers an event and calls all bound listeners.
  	   * @param {string} event - The event to trigger.
  	   * @param {...*} args - Arguments to pass to the listener functions.
  	   * @returns {boolean} True if the event had listeners, false otherwise.
  	   */
  	  emit(event, ...args) {
  	    const listeners = this.#events.get(event);
  	    if (!listeners || listeners.length === 0) return false;

  	    for (let i = 0, n = listeners.length; i < n; ++i) {
  	      try {
  	        listeners[i].apply(this, args);
  	      } catch (error) {
  	        console.error(`Error in listener for event '${event}':`, error);
  	      }
  	    }

  	    return true;
  	  }


  	  /**
  	   * Removes all listeners for a specific event or all events.
  	   * @param {string} [event] - The event to remove listeners from. If not provided, removes all listeners.
  	   * @returns {DPEventEmitter} The current instance for chaining.
  	   */
  	  removeAllListeners(event) {
  	    if (event) {
  	      this.#events.delete(event);
  	    } else {
  	      this.#events.clear();
  	    }
  	    return this;
  	  }
  	}

  	// Conditional export as Universal Module
  	if (module.exports) {
  	    // CommonJS (Node.js) export
  	    module.exports = DPEventEmitter;
  	} else if (typeof window !== 'undefined') {
  	    // Browser global export
  	    window.DPEventEmitter = DPEventEmitter;
  	} 
  } (dpEventEmitter));

  class PhysicsAnimator {

  	/**
  	 * Creates an instance of PhysicsAnimator.
  	 * @param {number} [attraction=0.026] - The attraction value for physics-based animation (0 < attraction < 1).
  	 * @param {number} [friction=0.28] - The friction value for physics-based animation (0 < friction < 1).
  	 */
  	constructor({ attraction = 0.026, friction = 0.28 } = {}) {

  		// Validate attraction
  		if (typeof attraction !== 'number' || attraction < 0 || attraction > 1) {
  			throw new Error('Attraction must be a number between 0 and 1.');
  		}
  		// Validate friction
  		if (typeof friction !== 'number' || friction < 0 || friction > 1) {
  			throw new Error('Friction must be a number between 0 and 1.');
  		}

  		this.attraction = attraction;
  		this.friction = friction;
  		this.frictionFactor = 1 - friction;

  		this.velocity = 0;
  		this.currentValue = 0;
  		this.targetValue = 0;

  		this.isAnimating = false;
  		this.prevTime = null;
  	}

  	/**
  	 * Animates from a start value to an end value.
  	 * @param {number} startValue - The starting value.
  	 * @param {number} endValue - The target value.
  	 * @param {function} callback - A callback function that receives the current value and progress.
  	 */
  	animateTo(startValue, endValue, velocity, callback) {

  		return new Promise((resolve) => {

  			this.currentValue = startValue;
  			this.targetValue = endValue;
  			this.velocity = velocity;
  			this.isAnimating = true;
  			this.prevTime = null;

  			const animate = (time) => {
  				if (!this.isAnimating) return;

  				if (this.prevTime === null) {
  					this.prevTime = time;
  					requestAnimationFrame(animate);
  					return;
  				}

  				const timeDelta = time - this.prevTime;
  				const timeDeltaFactor = timeDelta / 16.66; // Assuming 60 FPS baseline

  				this.prevTime = time;

  				// Calculate attraction force
  				const force = (this.targetValue - this.currentValue) * this.attraction;

  				// Update velocity
  				this.velocity += (force * timeDeltaFactor);

  				// Apply friction
  				this.velocity *= Math.pow(this.frictionFactor, timeDeltaFactor);

  				// Update current value
  				this.currentValue += this.velocity * timeDeltaFactor;

  				// Calculate progress
  				const totalDistance = this.targetValue - startValue;
  				const distanceCovered = this.currentValue - startValue;
  				let progress = 0;
  				if (totalDistance !== 0) {
  					progress = distanceCovered / totalDistance;
  				}

  				// Call the callback with the current value and progress
  				// callback(this.currentValue, progress);
  				callback({ position: this.currentValue, progress: progress});

  				// Check if animation is complete
  				if (Math.abs(this.currentValue - this.targetValue) < 0.01) {
  					this.isAnimating = false;
  					callback({ position: this.targetValue, progress: 1}); // Ensure we call the callback with final value
  					resolve();
  					return;
  				}

  				requestAnimationFrame(animate);
  			};

  			requestAnimationFrame(animate);

  		});
  	}

  	/**
  	 * Stops the ongoing animation.
  	 */
  	stop() {
  		this.isAnimating = false;
  	}


  	setAttraction(attraction){
  		if (typeof attraction !== 'number' || attraction < 0 || attraction > 1) {
  			throw new Error('Attraction must be a number between 0 and 1.');
  		}
  		this.attraction = attraction;
  	}

  	setFriction(friction){
  		if (typeof friction !== 'number' || friction < 0 || friction > 1) {
  			throw new Error('Friction must be a number between 0 and 1.');
  		}
  		this.friction = friction;
  		this.frictionFactor = 1 - friction;
  	}
  }

  return PhysicsAnimator;

})();
//# sourceMappingURL=physics-animator.min.js.map
