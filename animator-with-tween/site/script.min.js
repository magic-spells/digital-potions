
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var tweenCalculator_min = {exports: {}};

	(function (module, exports) {
		!function(e,t){module.exports=t();}(commonjsGlobal,(function(){return class{constructor(e){this.setKeyframes(e),this.discreteProperties=["display","position","float","clear","visibility","overflow","overflow-x","overflow-y","flex-direction","flex-wrap","justify-content","align-items","align-content","order","grid-template-columns","grid-template-rows","grid-template-areas","grid-auto-flow","z-index","table-layout","empty-cells","caption-side","list-style-type","list-style-position","pointer-events","user-select","box-sizing","resize","text-align","text-transform","white-space","word-break","word-wrap","font-style","font-weight","font-variant","background-repeat","background-attachment","background-position","border-style","border-collapse","content","page-break-before","page-break-after","page-break-inside"];}calculateTween(e){const t={},r=100*e,s=new Set(this.keyframes.flatMap((e=>Object.keys(e.styles))));for(const e of s)t[e]=this.interpolateProperty(e,r);return t}interpolateProperty(e,t){if(this.discreteProperties.includes(e))return this.interpolateDiscreteProperty(e,t);const r=this.keyframes.filter((t=>e in t.styles));if(0===r.length)return null;if(1===r.length)return r[0].styles[e];if(t<r[0].percent){const s=r[0],n=r[1]||r[0],a=(t-s.percent)/(n.percent-s.percent),l=s.styles[e],o=n.styles[e];return "transform"===e?this.extrapolateTransform(l,o,a,"below"):this.extrapolateValue(l,o,a,"below")}if(t>r[r.length-1].percent){const s=r.length-1,n=r[s-1]||r[s],a=r[s],l=(t-a.percent)/(a.percent-n.percent),o=n.styles[e],i=a.styles[e];return "transform"===e?this.extrapolateTransform(o,i,l,"above"):this.extrapolateValue(o,i,l,"above")}let s=r[0],n=r[r.length-1];for(let e=0;e<r.length-1;e++)if(t>=r[e].percent&&t<=r[e+1].percent){s=r[e],n=r[e+1];break}const a=s.styles[e],l=n.styles[e],o=(t-s.percent)/(n.percent-s.percent);return "transform"===e?this.interpolateTransform(a,l,o):this.interpolateValue(a,l,o)}extrapolateValue(e,t,r,s){return "above"===s?this.interpolateValue(t,t+(t-e)*r,r,!0):"below"===s?this.interpolateValue(e,e+(e-t)*r,r,!0):null}extrapolateTransform(e,t,r,s){const n=this.parseTransform(e),a=this.parseTransform(t),l=[],o=new Set([...Object.keys(n),...Object.keys(a)]);for(const e of o){const t=n[e]||(this.isNumericFunction(e)?{value:0,unit:"px"}:{value:0,unit:""}),o=a[e]||{value:t.value,unit:t.unit};if(Array.isArray(t.value)){const n=t.value.map(((e,t)=>{const n=o.value[t]||{value:e.value,unit:e.unit};let a=e.value;return "above"===s?a+=(n.value-e.value)*r:"below"===s&&(a+=(e.value-n.value)*r),`${this.formatNumber(a)}${e.unit||""}`}));l.push(`${e}(${n.join(", ")})`);}else {let n=o.value;"above"===s?n+=(o.value-t.value)*r:"below"===s&&(n+=(t.value-o.value)*r),l.push(`${e}(${this.formatNumber(n)}${t.unit||""})`);}}return l.join(" ")}formatNumber(e){return console.log("num",e),e=parseFloat(e),parseFloat(e.toFixed(4)).toString()}interpolateDiscreteProperty(e,t){const r=this.keyframes.filter((t=>e in t.styles));if(0===r.length)return null;return r.reduce(((e,r)=>r.percent<=t&&r.percent>e.percent?r:e)).styles[e]}interpolateTransform(e,t,r){const s=this.parseTransform(e),n=this.parseTransform(t),a=[],l=new Set([...Object.keys(s),...Object.keys(n)]);for(const e of l){const t=s[e]||(this.isNumericFunction(e)?{value:0,unit:"px"}:{value:0,unit:""}),l=n[e]||{value:t.value,unit:t.unit};if(Array.isArray(t.value)){const s=t.value.map(((e,t)=>{const s=l.value[t]||{value:e.value,unit:e.unit},n=this.interpolateValue(e.value,s.value,r,!0);return `${this.formatNumber(n)}${e.unit||""}`}));a.push(`${e}(${s.join(", ")})`);}else {const s=this.interpolateValue(t.value,l.value,r,!0);a.push(`${e}(${this.formatNumber(s)}${t.unit||""})`);}}return a.join(" ")}parseTransform(e){const t={},r=/(\w+)\(([^)]+)\)/g;let s;for(;null!==(s=r.exec(e));){const[,e,r]=s,n=r.split(/\s*,\s*|\s+/).map((e=>{const t=e.match(/^(-?\d*\.?\d+)(\D*)$/);return t?{value:parseFloat(t[1]),unit:t[2]}:{value:0,unit:""}}));n.length>1?t[e]=n:t[e]=n[0];}return t}interpolateValue(e,t,r,s=!1){if(this.isColor(e)&&this.isColor(t))return this.interpolateColor(e,t,r);if("number"==typeof e&&"number"==typeof t){const s=e+(t-e)*r;return this.formatNumber(s)}const n=this.parseValue(e),a=this.parseValue(t);if(n&&a&&n.unit===a.unit){let e=(n.value+(a.value-n.value)*r).toFixed(2);return e=e.replace(/\.00$/,"").replace(/(\.\d)0$/,"$1"),`${e}${n.unit||""}`}return r<1?e:t}parseValue(e){if("number"==typeof e)return {value:e,unit:""};const t=String(e).match(/^(-?\d*\.?\d+)(\D*)$/);return t?{value:parseFloat(t[1]),unit:t[2]}:null}isColor(e){return /^(#[0-9A-Fa-f]{6}|rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)|rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[\d.]+\s*\)|hsl\(\s*\d+\s*,\s*\d+%\s*,\s*\d+%\s*\)|hsla\(\s*\d+\s*,\s*\d+%\s*,\s*\d+%\s*,\s*[\d.]+\s*\))$/.test(e)}interpolateColor(e,t,r){const s=this.colorToRGB(e),n=this.colorToRGB(t),a=Math.round(s[0]+(n[0]-s[0])*r),l=Math.round(s[1]+(n[1]-s[1])*r),o=Math.round(s[2]+(n[2]-s[2])*r),i=e=>Math.max(0,Math.min(255,e));return `#${((1<<24)+(i(a)<<16)+(i(l)<<8)+i(o)).toString(16).slice(1).toUpperCase()}`}colorToRGB(e){if(e.startsWith("#"))return [parseInt(e.slice(1,3),16),parseInt(e.slice(3,5),16),parseInt(e.slice(5,7),16)];const t=e.match(/^rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\)$/);if(t)return [parseInt(t[1],10),parseInt(t[2],10),parseInt(t[3],10)];const r=e.match(/^rgba\s*\(\s*(\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\s*\)$/);if(r)return [parseInt(r[1],10),parseInt(r[2],10),parseInt(r[3],10)];if(e.match(/^hsl\s*\(\s*(\d+),\s*(\d+)%?,\s*(\d+)%?\s*\)$/))return this.hslToRGB(e);return e.match(/^hsla\s*\(\s*(\d+),\s*(\d+)%?,\s*(\d+)%?,\s*[\d.]+\s*\)$/)?this.hslToRGB(e):[0,0,0]}hslToRGB(e){const t=e.match(/^hsl[a]?\(\s*(\d+),\s*(\d+)%?,\s*(\d+)%?\s*\)$/);if(!t)return [0,0,0];let r=parseInt(t[1],10),s=parseInt(t[2],10)/100,n=parseInt(t[3],10)/100;r%=360,r<0&&(r+=360);const a=(1-Math.abs(2*n-1))*s,l=a*(1-Math.abs(r/60%2-1)),o=n-a/2;let i,u,c;[i,u,c]=0<=r&&r<60?[a,l,0]:60<=r&&r<120?[l,a,0]:120<=r&&r<180?[0,a,l]:180<=r&&r<240?[0,l,a]:240<=r&&r<300?[l,0,a]:[a,0,l];return [Math.round(255*(i+o)),Math.round(255*(u+o)),Math.round(255*(c+o))]}setKeyframes(e){this.keyframes=e.sort(((e,t)=>e.percent-t.percent));}isNumericFunction(e){return ["translate","translateX","translateY","translateZ","scale","scaleX","scaleY","scaleZ","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY","perspective"].includes(e)}interpolateDiscreteProperty(e,t){const r=this.keyframes.filter((t=>e in t.styles));if(0===r.length)return null;return r.reduce(((e,r)=>r.percent<=t&&r.percent>e.percent?r:e)).styles[e]}}})); 
	} (tweenCalculator_min));

	var tweenCalculator_minExports = tweenCalculator_min.exports;
	var TweenCalculator = /*@__PURE__*/getDefaultExportFromCjs(tweenCalculator_minExports);

	var physicsAnimator_min = {exports: {}};

	(function (module, exports) {
		(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r); })(self.document);
		(function (global, factory) {
		  module.exports = factory() ;
		})(commonjsGlobal, (function () {
		  var dpEventEmitter = {exports: {}};

		  (function (module) {
		  	class DPEventEmitter {
		  	  #events;

		  	  constructor() {
		  	    this.#events = new Map();
		  	  }

		  	  /**
		  	   * Binds a listener to an event.
		  	   * @param {string} event - The event to bind the listener to.
		  	   * @param {Function} listener - The listener function to bind.
		  	   * @returns {DPEventEmitter} The current instance for chaining.
		  	   * @throws {TypeError} If the listener is not a function.
		  	   */
		  	  on(event, listener) {
		  	    if (typeof listener !== 'function') {
		  	      throw new TypeError('Listener must be a function');
		  	    }

		  	    const listeners = this.#events.get(event) || [];
		  	    if (!listeners.includes(listener)) {
		  	      listeners.push(listener);
		  	    }
		  	    this.#events.set(event, listeners);

		  	    return this;
		  	  }

		  	  /**
		  	   * Unbinds a listener from an event.
		  	   * @param {string} event - The event to unbind the listener from.
		  	   * @param {Function} listener - The listener function to unbind.
		  	   * @returns {DPEventEmitter} The current instance for chaining.
		  	   */
		  	  off(event, listener) {
		  	    const listeners = this.#events.get(event);
		  	    if (!listeners) return this;

		  	    const index = listeners.indexOf(listener);
		  	    if (index !== -1) {
		  	      listeners.splice(index, 1);
		  	      if (listeners.length === 0) {
		  	        this.#events.delete(event);
		  	      } else {
		  	        this.#events.set(event, listeners);
		  	      }
		  	    }

		  	    return this;
		  	  }

		  	  /**
		  	   * Triggers an event and calls all bound listeners.
		  	   * @param {string} event - The event to trigger.
		  	   * @param {...*} args - Arguments to pass to the listener functions.
		  	   * @returns {boolean} True if the event had listeners, false otherwise.
		  	   */
		  	  emit(event, ...args) {
		  	    const listeners = this.#events.get(event);
		  	    if (!listeners || listeners.length === 0) return false;

		  	    for (let i = 0, n = listeners.length; i < n; ++i) {
		  	      try {
		  	        listeners[i].apply(this, args);
		  	      } catch (error) {
		  	        console.error(`Error in listener for event '${event}':`, error);
		  	      }
		  	    }

		  	    return true;
		  	  }


		  	  /**
		  	   * Removes all listeners for a specific event or all events.
		  	   * @param {string} [event] - The event to remove listeners from. If not provided, removes all listeners.
		  	   * @returns {DPEventEmitter} The current instance for chaining.
		  	   */
		  	  removeAllListeners(event) {
		  	    if (event) {
		  	      this.#events.delete(event);
		  	    } else {
		  	      this.#events.clear();
		  	    }
		  	    return this;
		  	  }
		  	}

		  	// Conditional export as Universal Module
		  	if (module.exports) {
		  	    // CommonJS (Node.js) export
		  	    module.exports = DPEventEmitter;
		  	} else if (typeof window !== 'undefined') {
		  	    // Browser global export
		  	    window.DPEventEmitter = DPEventEmitter;
		  	} 
		  } (dpEventEmitter));

		  class PhysicsAnimator {

		  	/**
		  	 * Creates an instance of PhysicsAnimator.
		  	 * @param {number} [attraction=0.026] - The attraction value for physics-based animation (0 < attraction < 1).
		  	 * @param {number} [friction=0.28] - The friction value for physics-based animation (0 < friction < 1).
		  	 */
		  	constructor({ attraction = 0.026, friction = 0.28 } = {}) {

		  		// Validate attraction
		  		if (typeof attraction !== 'number' || attraction < 0 || attraction > 1) {
		  			throw new Error('Attraction must be a number between 0 and 1.');
		  		}
		  		// Validate friction
		  		if (typeof friction !== 'number' || friction < 0 || friction > 1) {
		  			throw new Error('Friction must be a number between 0 and 1.');
		  		}

		  		this.attraction = attraction;
		  		this.friction = friction;
		  		this.frictionFactor = 1 - friction;

		  		this.velocity = 0;
		  		this.currentValue = 0;
		  		this.targetValue = 0;

		  		this.isAnimating = false;
		  		this.prevTime = null;
		  	}

		  	/**
		  	 * Animates from a start value to an end value.
		  	 * @param {number} startValue - The starting value.
		  	 * @param {number} endValue - The target value.
		  	 * @param {function} callback - A callback function that receives the current value and progress.
		  	 */
		  	animateTo(startValue, endValue, velocity, callback) {

		  		return new Promise((resolve) => {

		  			this.currentValue = startValue;
		  			this.targetValue = endValue;
		  			this.velocity = velocity;
		  			this.isAnimating = true;
		  			this.prevTime = null;

		  			const animate = (time) => {
		  				if (!this.isAnimating) return;

		  				if (this.prevTime === null) {
		  					this.prevTime = time;
		  					requestAnimationFrame(animate);
		  					return;
		  				}

		  				const timeDelta = time - this.prevTime;
		  				const timeDeltaFactor = timeDelta / 16.66; // Assuming 60 FPS baseline

		  				this.prevTime = time;

		  				// Calculate attraction force
		  				const force = (this.targetValue - this.currentValue) * this.attraction;

		  				// Update velocity
		  				this.velocity += (force * timeDeltaFactor);

		  				// Apply friction
		  				this.velocity *= Math.pow(this.frictionFactor, timeDeltaFactor);

		  				// Update current value
		  				this.currentValue += this.velocity * timeDeltaFactor;

		  				// Calculate progress
		  				const totalDistance = this.targetValue - startValue;
		  				const distanceCovered = this.currentValue - startValue;
		  				let progress = 0;
		  				if (totalDistance !== 0) {
		  					progress = distanceCovered / totalDistance;
		  				}

		  				// Call the callback with the current value and progress
		  				// callback(this.currentValue, progress);
		  				callback({ position: this.currentValue, progress: progress});

		  				// Check if animation is complete
		  				if (Math.abs(this.currentValue - this.targetValue) < 0.01) {
		  					this.isAnimating = false;
		  					callback({ position: this.targetValue, progress: 1}); // Ensure we call the callback with final value
		  					resolve();
		  					return;
		  				}

		  				requestAnimationFrame(animate);
		  			};

		  			requestAnimationFrame(animate);

		  		});
		  	}

		  	/**
		  	 * Stops the ongoing animation.
		  	 */
		  	stop() {
		  		this.isAnimating = false;
		  	}


		  	setAttraction(attraction){
		  		if (typeof attraction !== 'number' || attraction < 0 || attraction > 1) {
		  			throw new Error('Attraction must be a number between 0 and 1.');
		  		}
		  		this.attraction = attraction;
		  	}

		  	setFriction(friction){
		  		if (typeof friction !== 'number' || friction < 0 || friction > 1) {
		  			throw new Error('Friction must be a number between 0 and 1.');
		  		}
		  		this.friction = friction;
		  		this.frictionFactor = 1 - friction;
		  	}
		  }

		  return PhysicsAnimator;

		}));
		
	} (physicsAnimator_min));

	var physicsAnimator_minExports = physicsAnimator_min.exports;
	var PhysicsAnimator = /*@__PURE__*/getDefaultExportFromCjs(physicsAnimator_minExports);

	const animator = new PhysicsAnimator({ attraction: 0.01, friction: 0.07});

	const framesForward2 = [
	  {
	    percent: 0,
	    styles: {
	      transform: 'translateX(0px) translateY(0px) rotate(0deg) scale(1.0)',
	      backgroundColor: '#ff0000',
	      borderWidth: '1px'
	    }
	  },
	  {
	    percent: 100,
	    styles: {
	      transform: 'translateX(400px) translateY(400px) rotate(-360deg) scale(2.0)',
	      backgroundColor: '#ff00ff',
	      borderWidth: '10px'
	    }
	  }
	];





	const tweenCalculator = new TweenCalculator(framesForward2);
	const box = document.getElementById('box');
	const go = document.getElementById('go');

	function updateView({ position, progress }) {
	  // console.log('\nprogress', progress)
	  const tweenStyles = tweenCalculator.calculateTween(progress);
	  console.log(`tweenStyles ${progress}`, tweenStyles);
	  applyTweenStyles(box, tweenStyles);

	  // box.style.transform = `translate3d(${position}px,${position}px,0) scale(${progress * 2})`;
	      
	}

	function applyTweenStyles(element, styles) {
	  for (const [prop, value] of Object.entries(styles)) {
	    element.style[prop] = value;
	  }
	}


	go.addEventListener('click', function (argument) {
	  animator.animateTo(0, 500, 20, updateView)
	  .then(() => {
	    console.log('finished');
	    // tweenCalculator.setKeyframes(framesBack) 
	    // animator.animateTo(0, 500, 150, updateView);
	  });


	});

})();
//# sourceMappingURL=script.min.js.map
